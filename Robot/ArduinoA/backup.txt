
// Comandos de RPi
#include "headers/comandos.h"
#define LONGITUD_MENSAJE 20
char mensaje[LONGITUD_MENSAJE];
int comando;


// Modo de operación
int modo = MODO_INACTIVO; // empezar en modo de parada
int *modoPuntero = &modo;


// Controlador de motores
#include <SoftwareSerial.h>
#include "RoboClaw.h"
#define DIRECCION_MEMORIA_RC 0x80
#define V_LENTA 30 //30
#define V_NORMAL 40 //50
#define V_RAPIDA 50 //80
#define PORCENTAJE 0.6
SoftwareSerial serial(10, 11);    // 10 to S2 and 11 to S1
RoboClaw rc(&serial, 10000);


// Magnetometro
#include <Wire.h>
#include <Adafruit_LSM303.h>
#define ANGULO_DEC 0.011635528
Adafruit_LSM303 lsm;

// Direcciones
#define IZQUIERDA 'I'
#define DERECHA 'D'
#define RECTA 'R'
#define PARAR 'P'
#define ATRAS 'A'
#define ATRAS_IZQUIERDA 'i'
#define ATRAS_DERECHA 'd'
#define DESP_ADELANTE 0
#define DESP_ATRAS 1
#define DESP_GIRO 2
#define TOL_DIRECCION 10
#define TOL_SONAR 0.1 // tolerancia grados a girar
int direccionObj = 0;
int *direccionObjPuntero = &direccionObj;
int direccionAct = 0;
int *direccionActPuntero = &direccionAct;
int errorDireccion = 0; 
int *errorDireccionPuntero = &errorDireccion;

// Sonar
#define TRIGFI 2
#define ECHOFI 3
#define TRIGFD 8
#define ECHOFD 9
#define TRIGA 4
#define ECHOA 5
#define TRIGI 6
#define ECHOI 7
#define TRIGD 12 // TO DO after getting a new sonar, make two A pins digital
#define ECHOD 13 // TO DO after getting a new sonar, make two A pins digital
#define M_SONARFI 0.0177
#define B_SONARFI -0.8338
#define M_SONARFD 0.0178
#define B_SONARFD -0.3905
#define M_SONARA 0.0178
#define B_SONARA -0.9843
#define M_SONARI 0.0177
#define B_SONARI -0.3467
#define M_SONARD 0.0177 //to calibrate after we get sonar
#define B_SONARD -0.0027 //to calibrate after we get sonar

float distanciaSonarFI = 0.0;
float *distanciaSonarFIPuntero = &distanciaSonarFI;
float distanciaSonarFD = 0.0;
float *distanciaSonarFDPuntero = &distanciaSonarFD;
float distanciaSonarA = 0.0; 
float *distanciaSonarAPuntero = &distanciaSonarA;
float distanciaSonarI = 0.0; 
float *distanciaSonarIPuntero = &distanciaSonarI;  
float distanciaSonarD = 0.0; 
float *distanciaSonarDPuntero = &distanciaSonarD;

// Distancias !!TODO: find true paremeters for navegation
#define DISTANCIA_FILA 0.25//0.5 distancia que determina si estás en una fila o no
#define DISTANCIA_GIRO_MIN 0.25// !!TODO: find min distance needed to turn
#define DISTANCIA_GRANDE 1//10 
#define DISTANCIA_CORTA 0.4//3
#define DISTANCIA_OBSTACULO 0.2//1
#define DISTANCIA_PARADA 0.1//0.2
#define TOL_DISTANCIA 0.25 // para modo entre filas
#define MAX_INTENTOS 10 // !!TODO decide what to do with this variable
float distanciaObj = 0; // distancia recibida de Pi
float *distanciaObjPuntero = &distanciaObj; 
float distanciaAct = 0;
float *distanciaActPuntero = &distanciaAct;
int llegada = 1;
int *llegadaPuntero = &llegada;
#define RATIO_ENCODER_DISTANCIA 0.00594






void setup()
{
  Serial.begin(9600);
  lsm.begin();
  rc.begin(38400);

  pinMode(TRIGFI, OUTPUT);
  pinMode(ECHOFI, INPUT);
  pinMode(TRIGFD, OUTPUT);
  pinMode(ECHOFD, INPUT);
  pinMode(TRIGA, OUTPUT);
  pinMode(ECHOA, INPUT);
  pinMode(TRIGI, OUTPUT);
  pinMode(ECHOI, INPUT);
  pinMode(TRIGD, OUTPUT);
  pinMode(ECHOD, INPUT);
}


void loop()
{
  //delay(300);
  delay(1000);

  if (Serial.available())
  {
    int i;
    for (i = 0; Serial.available(); i++)
      mensaje[i] = Serial.read();
    mensaje[i] = '\0';
  }
  else
     memset(mensaje, 0, sizeof(mensaje));   // vaciar el mensaje (reinicializarlo a todo 0's) 
  
  comando = (int)convertirAfloat(mensaje, 1, 0); 

  if (comando == LEER_MODO)
  {
     Serial.println(modo);
  }  

  if (comando == CAMBIAR_MODO)
  {
     *modoPuntero = mensaje[2] - '0';
     Serial.println(modo);
  }   
  
  if (modo == MODO_INACTIVO)
  {
    parar();
    llegada = 1;
  }

  else if (modo == MODO_NAVEGACION)
  {
    if (comando == CONFIRMAR_LLEGADA)
      Serial.println(llegada);

    else if (comando == RECIBIR_DIRECCION_DISTANCIA_OBJ)
    {
      rc.ResetEncoders(DIRECCION_MEMORIA_RC);   // maybe when llegada becomes 1 in moverRobot()

      *direccionObjPuntero = (int)convertirAfloat(mensaje, 2, 2);
      *distanciaObjPuntero = convertirAfloat(mensaje, 6, 5);
 
      String direccionYdistanciaObj = String(direccionObj) + String(distanciaObj);
      Serial.println(direccionYdistanciaObj);
      
      llegada = 0; // was commented out
    }

    leerSonars(); // leer sonar FI, FD, I, D, A
//    Serial.print("distanciaSonarFI MAIN= ");  Serial.println(distanciaSonarFI);
//    Serial.print("distanciaSonarFD MAIN = ");  Serial.println(distanciaSonarFD);
//    Serial.print("distanciaSonarI = ");  Serial.println(distanciaSonarI);
//    Serial.print("distanciaSonarD = ");  Serial.println(distanciaSonarD);
//    Serial.print("distanciaSonarA = ");  Serial.println(distanciaSonarA);
//    Serial.println();

    leerMagnetometro(); // leer magnetometro
//    Serial.println(direccionAct);
    char giro = calcularGiro(); 
//    Serial.print("giro = ");  Serial.println(giro);
//    Serial.print("direccionObj = ");  Serial.println(direccionObj);
//    Serial.print("direccionAct = ");  Serial.println(direccionAct);
//    Serial.println();

    calcularDistanciaAct(distanciaActPuntero); // leer encoder y calcular distancia viajada multiplicando este numero por un ratio para convertir a metros
//    Serial.print("distanciaAct = ");  Serial.println(distanciaAct);
//    Serial.print("distanciaObj = ");  Serial.println(distanciaObj);
    
    float distAdesplazar = distanciaObj - distanciaAct;
//   Serial.print("distAdesplazar = ");  Serial.println(distAdesplazar);
    if (distAdesplazar <= 0.2)
    {
      llegada = 1;
      parar();
////      Serial.println("arrived");
    }
    else
      moverRobot(distanciaSonarIPuntero,distanciaSonarDPuntero,distanciaSonarFIPuntero,distanciaSonarFDPuntero,distanciaSonarAPuntero,giro,distAdesplazar,errorDireccionPuntero);
  }


















  if (mensaje[0] == 'p')
    parar();
    
  else if (mensaje[0] == 'a' && mensaje[1] == 'r')
    avanzarRecto(V_LENTA);
  else if (mensaje[0] == 'a' && mensaje[1] == 'i')
    avanzarIzquierda(V_LENTA);
  else if (mensaje[0] == 'a' && mensaje[1] == 'd')
    avanzarDerecha(V_LENTA);
  else if (mensaje[0] == 'r' && mensaje[1] == 'r')
    retrocederRecto(V_LENTA);
  else if (mensaje[0] == 'r' && mensaje[1] == 'i')
    retrocederIzquierda(V_LENTA);
  else if (mensaje[0] == 'r' && mensaje[1] == 'd')
    retrocederDerecha(V_LENTA);
  else if (mensaje[0] == 'g' && mensaje[1] == 'i')
    giroIzquierda(V_LENTA);
  else if (mensaje[0] == 'g' && mensaje[1] == 'd')
    giroDerecha(V_LENTA);
  else if (mensaje[0] == 'z' && mensaje[1] == 'e')
    rc.ResetEncoders(DIRECCION_MEMORIA_RC);
    
//  else if (mensaje[0] == 'M')
//  {
//    leerMagnetometro(direccionActPuntero);
//    Serial.println(direccionAct);
//  }
//  else if (mensaje[0] == 'n')
//  {
//    Serial.println(modo);
//  }
}

// Convertir array a float
float convertirAfloat(char mensaje[], int numDigitos, int comienzoMensaje)
{
  int i;
  char vector[LONGITUD_MENSAJE];

  for (i = 0; i <= numDigitos; i++)
    vector[i] = mensaje[i + comienzoMensaje];
  vector[i] = '\0';

  return atof(vector);
}


